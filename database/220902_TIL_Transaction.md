# Transaction 기초 다시 잡기 🌱

<br>

## 📚 ACID 

<br>

### A : Atomicity - 원자성 

- 트랜잭션은 더 이상 분해가 불가능한 업무의 최소단위. 
- 전부 처리 되거나 ( ``commit`` ) 하나도 처리 되지 않아야 ( ``rollback ``)한다. 


### C : Consistency - 일관성 

- 하나의 데이터베이스는 일관된 상태를 가져야 한다.
- 일관된 상태의 데이터베이스에서 하나의 트랜잭션이 성공적으로 완료되면, 그 데이터베이스는 여전히 일관된 상태여야 한다. 
- 트랜잭션의 실행 결과로 데이터베이스 상태가 일관되지 못하면 안된다. 


### I : Isolation - 격리성 

- 완료 되지 않은 트랜잭션의 중간결과에 다른 트랜잭션이 접근 할 수 없다.
- 하나의 트랜잭션은 철저히 다른 트랜잭션과 격리 되어야 한다.


### D : Durability - 영속성

- 트랜잭션이 성공적으로 완료 되면, 그 실행 결과는 데이터베이스에 영속적으로 저장된다.

<br>

## 트랜잭션 격리성으로 인해 나타날 수 있는 문제

<br>

### Dirty Read

<br>

- 정의 : 다른 트랜잭션에 의해 수정 되었지만 아직 커밋되지 않은 데이터를 읽는 것

- A 트랜젝션이 정적으로 처리 되지 않았을 때 B 트랜잭션이 변경된 값을 읽어 온다면, 잘못된 값으로 B 트랜잭션을 통한 비지니스 로직이 처리 될 상황이 생길 수 있다.


### Non-Repeatable Read

<br>

- 정의 : 한 트랙잭션 내에서 같은 Key 를 가진 데이터를 두 번 읽었는데, 그 사이에 값이 변경되거나 삭제 되어서 결과가 다르게 나타는 현상

- A 트랜잭션에서 하나의 값을 읽었는데, B 트랜잭션에서 동알한 값의 데이터를 update 하고 commit 하였다면, A 트랜잭션 내에서 다시 그 데이터를 읽었을 때 다른 데이터를 들고 로직을 처리할 상황이 생길 수 있다.


### Phantom Read

<br>

- 정의 : 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데, 첫번째 쿼리에서 없던 정보 (phantom record) 가 두번째 쿼리 수행 시 나타나는 현상

- A 트랜잭션에서 commit 하기 전 insert 쿼리를 날리고, 그 중간에 B 트랜잭션에서 조회 쿼리를 날린 후에, A 트랜잭션에서 commit 을 통해 데이터가 변경 시키고, 다시 B 트랜잭션에서 조회 쿼리를 날리면 결과가 다르게 나타나는 상황이 생길 수 있다. 

<br>

## 지정할 수 있는 격리성 수준

<br>

### Read Uncommitted

<br>

- 트랜잭션에서 처리 중인 아직 커밋 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용하는 것. 
- 위의 3가지 격리성으로 인해 나타날 수 있는 문제가 발생 가능하다. 
- 데이터베이스 정합성에 문제가 있기에 권장하지 않음


### Read Committed

<br>

- 트랜잭션이 커밋되어 확정된 데이터만 다른 트랜잭션이 읽도록 허용함. -> Dirty Read 예방
- 커밋 되지 않은 데이터에 대해서는 실제 데이터베이스 데이터가 아니라 Undo 로그에 있는 이전 데이터를 조회 하는것.
- Non-Repeatable Read 와 Phantom Read 에 대해서는 발생 가능성이 있음. 


### Repeatable Read

<br>

- 트랜잭션 내에서 삭제, 변경에 대해 Undo 로그에 넣어두고, 앞서 발생한 트랜잭션에 대해서는 실제 데이터가 아닌 Undo 로그에 있는 백업 데이터를 조회함.

- 트랜잭션 중 값의 변경에 대해 일관성 있는 값으로 처리가 가능하다. 

- 삭제와 수정에 대해 한 트랜잭션내에서 불일치를 가져오던 Non-Reapeatable Read 해소 가능


### Serializable Read

<br>

- 트랜잭션 내에서 쿼리를 두 번 이상 수행할 때, 첫 번째 쿼리에 있던 레코드가 사라지거나 값이 바뀌지 않고 새로운 레코드가 나타나지도 않도록 하는 설정.



